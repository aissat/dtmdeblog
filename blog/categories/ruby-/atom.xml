<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby, | مدونة الطيب الضادي]]></title>
  <link href="http://tayeb83.github.com/dtmdeblog/blog/categories/ruby-/atom.xml" rel="self"/>
  <link href="http://tayeb83.github.com/dtmdeblog/"/>
  <updated>2013-11-09T23:20:51+01:00</updated>
  <id>http://tayeb83.github.com/dtmdeblog/</id>
  <author>
    <name><![CDATA[طيب مرابطي]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[تهيئة gedit من أجل روبي أون رايلز]]></title>
    <link href="http://tayeb83.github.com/dtmdeblog/blog/2013/11/09/gedit-configuration/"/>
    <updated>2013-11-09T23:07:00+01:00</updated>
    <id>http://tayeb83.github.com/dtmdeblog/blog/2013/11/09/gedit-configuration</id>
    <content type="html"><![CDATA[<p>أنا لست محب للمحررات التي معظمها ثقيلة نوعا ما و إن كانت فعالة مثل Eclipse أو RubyMine، لهذا فإنني أُُُفضل  محررا بسيط مثل gedit على الubuntu  مع استعمال حوسبة تساعد في تهيئة المحرر.</p>

<!-- more -->


<p>لو تستعملون  textmate فسنحاول أن نحول الgedit لشبيه هذا المحرر حتى نكون فعالين. لهذا و حتى نُحسن من المحرر gedit سنتعمل مجموعة من الحوسبة.</p>

<p>في البداية سنضيف مخزن PPA يحتوي على حوسبات رايلز. داخل الterminal, يمكنكم ارسال الأمر التالي :</p>

<p><img src="http://tayeb83.github.com/dtmdeblog/images/geditConfig/intr1.png" title="intr1"/></p>

<p>بعدها نقوم  بتثبيث حزمة المكونات الإضافية داخل أبونتو و تلك المتعلقة برايلز من خلال المخزن الذي أضفناه من خلال الأمر التالي كما هو موضح  في الصورة :</p>

<p><img src="http://tayeb83.github.com/dtmdeblog/images/geditConfig/intr2.png" title="intr2"/></p>

<p>انتهينا، الآن يمكننا فتح  gedit و الذهاب إلى الPreferences و من ثم الأيقونة greffons للحصول على الأدوات المتعددة التي تم تثبيثها كما هو موضح في الصورة :</p>

<p><img src="http://tayeb83.github.com/dtmdeblog/images/geditConfig/preferences de gedit_002.png" title="pref2"/></p>

<p>أو الأيقونة  : Polices &amp; Couleurs لتبديل الألوان و التي تسمح باختيار التيمات التي تريدونها، على سبيل المثال : تيمات الموقع railscast للذين يعرفونه كما هو موضح في الصورة :</p>

<p><img src="http://tayeb83.github.com/dtmdeblog/images/geditConfig/pref003.png" title="pref3"/></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[تطبيق عملي لقياس سرعةالكود بروبي]]></title>
    <link href="http://tayeb83.github.com/dtmdeblog/blog/2013/08/02/benchmarking-profiling-ruby-example/"/>
    <updated>2013-08-02T19:56:00+02:00</updated>
    <id>http://tayeb83.github.com/dtmdeblog/blog/2013/08/02/benchmarking-profiling-ruby-example</id>
    <content type="html"><![CDATA[<p>في هذا المقال و كتطبيق وتتمة للمقال السابق سنقوم بدراسة بسيطة نقوم من خلالهابمقارنة أسرع خوارزمية لحساب متتالية fibonacci المعروفة.</p>

<p>في المثال سنستعمل طريقتين لحساب المتتالية و نقوم  بمقارنة الأسرع بينهما من خلال تطبيق ما شرحناه في المقال السابق حول الbenchmarking.</p>

<!-- more -->


<p>متتالية فيبوناتشي أو أعداد فيبوناتشي في الرياضيات هي الأرقام التي تكون في المتتالية التالية:</p>

<p>0,1,1,2,3,5,8,13,21...</p>

<p>و التي تحسب يالطريقة  التالية :</p>

<p>Fn=Fn-1 + Fn-2</p>

<p>مع القيم الناتجة منها : F0=1 و F1=1</p>

<p>في المثال سنقوم بعرض طريقتين :  الأولى باستعمال المقارنة العادية  و الثانية باستعمال include كما هو موضح  في الصورة.
<img src="http://tayeb83.github.com/dtmdeblog/images/rubyBenchmark/fibonacci_algorithm.png" title="fibonacci_algorithm"/></p>

<p>لمقارنة و لقياس السرعة  سنقوم باستعمال المقياس benchmark الذي شرحناه سابقا كما هو موضح  في الصورة :</p>

<p><img src="http://tayeb83.github.com/dtmdeblog/images/rubyBenchmark/benchmark_fibonacci.png" title="benchmark_fibonacci"/></p>

<p>للقياس سنقوم  بتغيير n من خلال أخذ ثلاث قيم مختلفة : 15, 25, 35. النتيجة موضحة في الصورة :</p>

<p><img src="http://tayeb83.github.com/dtmdeblog/images/rubyBenchmark/benchmark_fibonacci_result.png" title="benchmark_fibonacci_result"/></p>

<p>النتيجة توضح أن وبعد ما يكون n أكبر من 25 نلاحظ تباين في سرعة تنفيذ المتتالية بين الطريقتين بحيث أن الطريقة التي تستعمل الinclude تأخد أكبر وقت من الطريقة التي تستعمل طريقة المقارنة البديهية.</p>

<p>أتمنى بهذا التطبيق و المقال السابق أنها تكونت لديكم فكرة أكثر وضوحا حول استعمال الbenchmarking بروبي.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[قياس و اختبار سرعة الكود بروبي]]></title>
    <link href="http://tayeb83.github.com/dtmdeblog/blog/2013/08/02/benchmarking-profiling-ruby/"/>
    <updated>2013-08-02T12:45:00+02:00</updated>
    <id>http://tayeb83.github.com/dtmdeblog/blog/2013/08/02/benchmarking-profiling-ruby</id>
    <content type="html"><![CDATA[<p>في البرمجة بعد تصحيح كل الأخطاء و التأكد من عمل الكود من الطبيعي أن نفكر بعدها أن الكود جاهز للعمل؛ و لكن عمليا الكود و في كثير من الأحيان يشتغل ببطأ أو يكون أقل فعالة من ما هو منتظر. و رغم التطور الملحوظ من جانب السرعة مع تطور النسخ المختلفة لروبي منذ ال1.8 إلى ال2.0 حاليا إلا اننا سنحتاج لأدوات تسمح لنا بقياس و اختبار سرعة و فعالية الكود كليا أو في بعض أجزاءه.</p>

<!-- more -->


<p>الbenchmark  أو اختبار السرعة يمثل الخطوات المتبعة التي تجعل من الكود أو التطبيق يقوم بعملية أو وظيفة معينة و من خلالها نقوم بقياس سرعة تنفيذ هذه العملية. يمكنكم بعدها و من خلال حساب هذا الوقت تحسين أداء الكود أو البرنامج الخاص بكم و تقليله إلى أبعد حد ممكن.</p>

<h2>الطريقة البديهية </h2>

<p>للقيام بعملية القياس، ruby يحوي مكتبة تسمى benchmark. هذه المكتبة تتوفر على وظائف عديدة يمكنها قياس سرعة التنفيد للكود كليا. على سبيل المثال :</p>

<p><img src="http://tayeb83.github.com/dtmdeblog/images/rubyBenchmark/rubyBenchmark1.png" title="benchmark1"/></p>

<p><img src="http://tayeb83.github.com/dtmdeblog/images/rubyBenchmark/rubyBenchmarkResult1.png" title="benchmarkresult1"/></p>

<p>الخانات و من اليسار تعبر بالترتيب عن :</p>

<ul>
<li>الوقت cpu للمستخدم</li>
<li>الوقت cpu للنظام</li>
<li>الوقت cpu الكلي</li>
<li>الوقت الفعلي (الذي يهمنا كثيرا)</li>
</ul>


<p>و بما أن الوظيفة measure بامكانها التعامل مع كتل أو مجموعات منفصلة داخل نفس الكود، فإنه بإمكاننا كتابة قياسات بشكل أحسن و أدق مثل ما هو موضح في الكود التالي :</p>

<p><img src="http://tayeb83.github.com/dtmdeblog/images/rubyBenchmark/rubyBenchmark2.png" title="rubyBenchmark2"/></p>

<p>في هذا المثال قمنا بقياس كتلتين مختلفتين داخل نفس الكود، و النتيجة قياسان لكل كتلة كما هو موضح في الصورة:</p>

<p><img src="http://tayeb83.github.com/dtmdeblog/images/rubyBenchmark/benchmarkRubyResult2.png" title="benchmarkRubyResult2"/></p>

<p>النتيجة و إن أردنا تحليلها توضح اختلاف صغير بين الوظيفتين : for  و times و إن كانت النتيجة توضح أن for تستهلك وقتcpu مستخدم أكثر من times.</p>

<h2>الProfilng لاكثر دقة في القياس :</h2>

<p>إذا كان الbenchmarking يقوم بقياس الوقت الكلي لتنفيذ أمر ما و مقارنته مع نسخ أخرى للكود، فإن الprofiling هو العملية التي ستعطينا المعلومة التالية : "وقت تنفيذ لكل كود داخل الكود الاجمالي" ، على سببل المثال إذا فرضنا أن في داخل الكود هناك سطر يشوش في أداء البرنامج، باستعمال  الprofiling يمكنكم تحديد و مباشرة المشكل الذي يسبب بطأ البرنامج.</p>

<p>ruby يحوي على خاصية الprofiling، ما علينا سوى إضافة :</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>require "profile"</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>في بداية الكود و انتهى الأمر.</p>

<p>لنأخذ مثال كامل :
<img src="http://tayeb83.github.com/dtmdeblog/images/rubyBenchmark/rubyProfiling1.png" title="profiling1"/></p>

<p>النتيجة موضحة في الصورة المرفقة، معلومات كثيرة تمت كتابتها و لكن قراءتها جد سهلة.</p>

<p><img src="http://tayeb83.github.com/dtmdeblog/images/rubyBenchmark/rubyProfilingResult1.png" title="profilingresult"/></p>

<p>الخانة الأولى من اليسار تعبر عن نسبة الوقت المستغرق للوظيفة التي توجد على أقصى اليمين، في المثال الprofiler  أخبرنا بأن 100% من الاجمالي لوقت التنفيذ تم استهلاكه من الوظيفة times في الinteger كلاس. الخانة الثانية تمثل الوقت المستغرق بالثواني.
الخانة calls تحدد عدد المرات التي ارسلت للوظيفة. في هذه الحالة الوظيفة times تم ارسالها مرتين.
خلاصة القول، أنه يمكنكم استعمال نتيجة الprofiler لتحديد نقطة الضعف في الكود و تحسينها.</p>

<p>تقبل الله الصيام  والقيام...</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[التعابير النمطية و روبي - الجزء الثاني]]></title>
    <link href="http://tayeb83.github.com/dtmdeblog/blog/2013/06/10/regexp-ruby-p2/"/>
    <updated>2013-06-10T19:49:00+02:00</updated>
    <id>http://tayeb83.github.com/dtmdeblog/blog/2013/06/10/regexp-ruby-p2</id>
    <content type="html"><![CDATA[<p>هذا المقال هو تكملة للمقال السابق الذي بدأته حول التعابير النمطية في روبي. في هذا المقال سأبدأ بتكملة الأمثلة التي بدأتها سابقا ثم أنتقل إلى طريقة البحث و الاستبدال.</p>

<!-- more -->


<h2>تكملة  الأمثلة</h2>

<h2>التكرار الجشع : </h2>

<p><img src="http://tayeb83.github.com/dtmdeblog/images/regexp_ruby/repetition_gourmande.png" title="ruby_Regexp_gorumande"/></p>

<h2>التجميع بواسطة الحاضنتين :</h2>

<p><img src="http://tayeb83.github.com/dtmdeblog/images/regexp_ruby/group_parentese.png" title="ruby_Regexp_grouping"/></p>

<h2>البدائل :</h2>

<p><img src="http://tayeb83.github.com/dtmdeblog/images/regexp_ruby/replacement.png" title="ruby_Regexp_replacement"/></p>

<h2>المراسي anchors :</h2>

<p>المراسي عبارة عن أحرف أو بالأحرى رموز تساعد في حصر موقع التعبير النمطي :</p>

<p><img src="http://tayeb83.github.com/dtmdeblog/images/regexp_ruby/anchor.png" title="ruby_Regexp_anchor"/></p>

<h2>البحث و الاستبدال :</h2>

<p>من أهم الطرق أو العمليات الخاصة بالسلاسل في روبي العمليتين  sub و gsub. هاتين العمليتين تقومان بالبحث و الاستبدال على سلاسل الحروف باستعمال التعابير النمطية. أين sub تستبدل الحدوث الأول بينما gsub تستبدل كل الحوادث داخل السلسلة، لنأخذ أمثلة على ذلك :</p>

<p><img src="http://tayeb83.github.com/dtmdeblog/images/regexp_ruby/example_sub_gsub_1.png" title="ruby_Regexp_gsub1"/></p>

<p><img src="http://tayeb83.github.com/dtmdeblog/images/regexp_ruby/results_sub_gsub_1.png" title="ruby_Regexp_gsub1_result"/></p>

<p>في المثال الأول النتيجة موضحة في الصورة المرفقة أين قمنا بحذف التعليقات بالsub  بينما قمنا بحذف كل مل هو حرف ماعدا  الأرقام بواسطة gsub.</p>

<p>في المثال الثاني و بطريقتين مختلفتين باستعمال gsub فقط،  قمنابتكبير الحرف الأول من  كلمة tayeb إلى Tayeb.</p>

<p><img src="http://tayeb83.github.com/dtmdeblog/images/regexp_ruby/example_sub_gsub_2.png" title="ruby_Regexp_gsub_2"/></p>

<p><img src="http://tayeb83.github.com/dtmdeblog/images/regexp_ruby/result_sub_gsub_2.png" title="ruby_Regexp_gsub2_result"/></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[التعابير النمطية و روبي - الجزء الأول]]></title>
    <link href="http://tayeb83.github.com/dtmdeblog/blog/2013/05/21/regexp-ruby/"/>
    <updated>2013-05-21T21:44:00+02:00</updated>
    <id>http://tayeb83.github.com/dtmdeblog/blog/2013/05/21/regexp-ruby</id>
    <content type="html"><![CDATA[<p>هل حلمتم يوما بتعلم الصينية؟ ممتاز في هذا المقال سوف أعلمكم شيئا يشبهها, أي أنه يمكنكم كتابة شيء مثل هذا :</p>

<pre><code>        (((https?|ftp)://(w{3}\.)?)(?&lt;!www)(\w+-?)*\.([a-z]{2,4}))
</code></pre>

<p>هذا ما نسميه  التعابير النمطية أو  regular expression.
التعابير النمطية عبارة  عن نظام قوي و سريع للبحث عل سلسلة معينة من الحروف داخل سلاسل كبيرة (جملة، نصوص...)، أو بعبارة أخرى هو استعمال وظيفة ابحث/استبدل  بطريقة جد متطورة و التي لا يمكنكم التخلي عنها فور تعلمها و استعمالها.</p>

<!-- more -->


<p>فالتعابير النمطية سوف تسمح لنا بالبحث و الاستبدال داخل الجُمل و النصوص بطريقة فعالة  وسريعة  في نفس الوقت، و هذه بعض الأمثلة مما يمكن أن نفعله  باستعمالها :</p>

<ul>
<li><p>التأكد من أن البريد الإلكتروني الذي تم ادخاله من طرف المستخدم  صحيح الشكل مثل : tayeb@gmail.com.</p></li>
<li><p>تبديل شكل كتابة التاريخ  من الطريقة  الأمريكية  (2010-05-08) إلى الطريقة  الأوروبية مثلا (05/8/2012).</p></li>
<li><p>القيام  بعملية  بحث و استبدال معقدة داخل نص كبير.</p></li>
</ul>


<p>و هلم جر من العمليات المعقدة  التي يمكن القيام بها على النصوص أو الصفحات و التي لا تعد و لا تحصى.
الشيء الجميل الذي يمكن البدأ به هو أن كل لغات البرمجة (على كل حال التي أعرفها ) لا تحتاج لتفعيل أي مكتبة أو برنامج خاص للعمل بالتعابير النمطية و هذا لكثرة استعمالاتها.
في هذا المقال و إن كنت مُحبًا لperl في التعامل مع التعابير النمطية، سوف أركز على ruby تماشيا مع نمط المدونة و باعتبارها لغة تشبه perl في العديد من المواصفات  و التي من بينها التعابير النمطية.</p>

<h2>التركيب :</h2>

<p>داخل روبي التعبيرات النمطية لها الشكل التالي :</p>

<pre><code>                            /pattern/modifiers
</code></pre>

<p>بحيث تعبر  pattern عن التعبير و modifiers عن متغيرات نمط الربط. فيما يخص هذه الأخيرة  فإن روبي يدعم المتغيرات التالية :</p>

<ul>
<li><p>"i" تجاهل حالة الأحرف عند مطابقة النصوص</p></li>
<li><p>"o" يقوم بالربط مرة واحدة فقط</p></li>
<li><p>"x" تجاهل الفضاءات الخالية</p></li>
<li><p>"m" يسمح بالربط على مجموعة من السطور بحيث أن الرجوع إلى السطر يعتبره حرفا من الحروف.</p></li>
</ul>


<p>بالاضافة  إلى انه يمكننا مزج  العديد من هذه المتغيرات مع تعبير نمطي واحد، فمثلا لتجاهل حالة  الأحرف و الفضاءات الخالية نمزج المتغيرين التاليين : ix/.</p>

<h2>نماذج التعابير النمطية في روبي :</h2>

<p>باستثناء أحرف التحكم (+ ? . * ^ $ ( ) [ ] { } | ) ، كل حرف يطابق نفسه، كما أنه يمكن الغاء خاصية  التحكم في الحروف باستعمال الخط المائل العكسي backslash "\".
هذه اهم تركيبات التعابير النمطية الموجودة  داخل روبي :</p>

<p><img src="http://tayeb83.github.com/dtmdeblog/images/regexp_ruby/ruby_Regexp.png" title="ruby_Regexp"/></p>

<h2>أمثلة التعابير النمطية :</h2>

<h2>ربط الأحرف و الأرقام  :</h2>

<p><img src="http://tayeb83.github.com/dtmdeblog/images/regexp_ruby/caracter_class.png" title="rubyversion"/></p>

<h2>حالات التكرار :</h2>

<p><img src="http://tayeb83.github.com/dtmdeblog/images/regexp_ruby/reptetive_case.png" title="rubyversion"/></p>

<p>في الجزء الثاني إن شاءالله، سأكمل الامثلة المتداولة و سوف أعرض لكم طريقة البحث و الاستبدال بواسطة روبي و التعابير النمطية.</p>
]]></content>
  </entry>
  
</feed>
